[[_advanced_merging]]
//////////////////////////
=== Advanced Merging
//////////////////////////
=== 高度なマージ手法

//////////////////////////
Merging in Git is typically fairly easy.
Since Git makes it easy to merge another branch multiple times, it means that you can have a very long lived branch but you can keep it up to date as you go, solving small conflicts often, rather than be surprised by one enormous conflict at the end of the series.
//////////////////////////
Git を使うと、大抵の場合マージは簡単です。違うブランチを何度もマージすることも簡単なので、一度作ったブランチで延々と作業を続けながら、常に最新の状態に保っておけます。そうすれば、マージのたびに少しずつコンフリクトを解消することになるので、作業の最後で一度だけマージする場合のように、膨大なコンフリクトにあっけにとられることもなくなるでしょう。

//////////////////////////
However, sometimes tricky conflicts do occur.
Unlike some other version control systems, Git does not try to be overly clever about merge conflict resolution.
Git's philosophy is to be smart about determining when a merge resolution is unambiguous, but if there is a conflict, it does not try to be clever about automatically resolving it.
Therefore, if you wait too long to merge two branches that diverge quickly, you can run into some issues.
//////////////////////////
とはいえ、ややこしいコンフリクトは発生してしまうものです。他のバージョン管理システムとは違い、Git は無理をしてまでコンフリクトを解消しようとはしません。Git は、マージの内容が明確かどうか正確に判断できるよう作られています。しかし、コンフリクトが発生した場合は、わかったつもりになってコンフリクトを解消してしまうようなことはしません。すぐに乖離してしまうようなブランチをいつまでもマージしないでおくと、問題になる場合があります。

//////////////////////////
In this section, we'll go over what some of those issues might be and what tools Git gives you to help handle these more tricky situations.
We'll also cover some of the different, non-standard types of merges you can do, as well as see how to back out of merges that you've done.
//////////////////////////
この節では、どういった問題が起こりうるのか、そしてそういった状況を解決するのに役立つ Git のツールを見ていきます。また、いつもとは違う方法でマージを行うにはどうすればいいか、マージした内容を元に戻すにはどうすればいいかも見ていきましょう。

//////////////////////////
==== Merge Conflicts
//////////////////////////
==== マージのコンフリクト

//////////////////////////
While we covered some basics on resolving merge conflicts in <<_basic_merge_conflicts>>, for more complex conflicts, Git provides a few tools to help you figure out what's going on and how to better deal with the conflict.
//////////////////////////
マージのコンフリクトをどのように解消するか、基本的なところを <<_basic_merge_conflicts>> で紹介しました。ここでは、複雑なコンフリクトの場合に、状況を把握しコンフリクトを上手に解消するための Git ツールを紹介します。

//////////////////////////
First of all, if at all possible, try to make sure your working directory is clean before doing a merge that may have conflicts.
If you have work in progress, either commit it to a temporary branch or stash it.
This makes it so that you can undo *anything* you try here.
If you have unsaved changes in your working directory when you try a merge, some of these tips may help you lose that work.
//////////////////////////
まず、可能な限り、作業ディレクトリがクリーンな状態であることを確認しましょう。コンフリクトを起こす可能性のあるマージを実行するのはその後です。作業中の内容があるのなら、一時保存用のブランチを作ってコミットするか stash に隠してしまいましょう。こうしておけば、*何が* 起こってもやり直しがききます。以下で説明するヒントのなかには、作業ディレクトリの変更を保存せずにマージを行うと未保存の作業が消えてしまうものもあります。

//////////////////////////
Let's walk through a very simple example.
We have a super simple Ruby file that prints 'hello world'.
//////////////////////////
では、わかりやすい例を見てみましょう。'hello world' と出力する単純な Ruby スクリプトです。

[source,ruby]
----
#! /usr/bin/env ruby

def hello
  puts 'hello world'
end

hello()
----

//////////////////////////
In our repository, we create a new branch named `whitespace` and proceed to change all the Unix line endings to DOS line endings, essentially changing every line of the file, but just with whitespace.
Then we change the line ``hello world'' to ``hello mundo''.
//////////////////////////
このスクリプトが保存されているリポジトリに `whitespace` というブランチを作ったら、ファイルの改行コードを Unix から DOS に変更します。これで、空白文字だけが全行分変更されました。次に、``hello world'' という行を ``hello mundo'' に変更してみます。

[source,console]
----
$ git checkout -b whitespace
Switched to a new branch 'whitespace'

$ unix2dos hello.rb
unix2dos: converting file hello.rb to DOS format ...
$ git commit -am 'converted hello.rb to DOS'
[whitespace 3270f76] converted hello.rb to DOS
 1 file changed, 7 insertions(+), 7 deletions(-)

$ vim hello.rb
$ git diff -b
diff --git a/hello.rb b/hello.rb
index ac51efd..e85207e 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,7 @@
 #! /usr/bin/env ruby

 def hello
-  puts 'hello world'
+  puts 'hello mundo'^M
 end

 hello()

$ git commit -am 'hello mundo change'
[whitespace 6d338d2] hello mundo change
 1 file changed, 1 insertion(+), 1 deletion(-)
----

//////////////////////////
Now we switch back to our `master` branch and add some documentation for the function.
//////////////////////////
ここで `master` ブランチに切り替えて、コメントで機能を説明しておきましょう。

[source,console]
----
$ git checkout master
Switched to branch 'master'

$ vim hello.rb
$ git diff
diff --git a/hello.rb b/hello.rb
index ac51efd..36c06c8 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello world'
 end

$ git commit -am 'document the function'
[master bec6336] document the function
 1 file changed, 1 insertion(+)
----

//////////////////////////
Now we try to merge in our `whitespace` branch and we'll get conflicts because of the whitespace changes.
//////////////////////////
では、`whitespace` ブランチをマージしてみましょう。空白文字を変更したため、コンフリクトが発生してしまいます。

[source,console]
----
$ git merge whitespace
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.
----

//////////////////////////
[[_abort_merge]]
===== Aborting a Merge
//////////////////////////
===== マージの中止

//////////////////////////
We now have a few options.
First, let's cover how to get out of this situation.
If you perhaps weren't expecting conflicts and don't want to quite deal with the situation yet, you can simply back out of the merge with `git merge --abort`.
//////////////////////////
コンフリクトには、対応方法がいくつかあります。まず、現状から抜け出す方法を説明します。コンフリクトが起こるとは思っていなかった、今はまだ処理したくない、といった場合、`git merge --abort` を実行すればマージ後の状況から抜け出せます。

[source,console]
----
$ git status -sb
## master
UU hello.rb

$ git merge --abort

$ git status -sb
## master
----

//////////////////////////
The `git merge --abort` option tries to revert back to your state before you ran the merge.
The only cases where it may not be able to do this perfectly would be if you had unstashed, uncommitted changes in your working directory when you ran it, otherwise it should work fine.
//////////////////////////
`git merge --abort` が実行されると、マージを実行する前の状態に戻ろうとします。これがうまくいかない可能性があるのが、作業ディレクトリの変更を隠しておらず、コミットもしていない状態でこのコマンドが実行された場合です。それ以外で失敗することはないでしょう。

//////////////////////////
If for some reason you just want to start over, you can also run `git reset --hard HEAD`, and your repository will be back to the last committed state.
Remember that any uncommitted work will be lost, so make sure you don't want any of your changes.
//////////////////////////
また、一度やり直したいときは、`git reset --hard HEAD` （もしくは戻りたいコミットを指定）を実行してもよいでしょう。最新コミットの状態にリポジトリを戻してくれます。
ただし、コミットしていない内容が消去されてしまうことだけは覚えておいてください。変更内容をなかったことにしたいときだけ、このコマンドを実行するようにしましょう。

//////////////////////////
===== Ignoring Whitespace
//////////////////////////
===== 空白文字の除外

//////////////////////////
In this specific case, the conflicts are whitespace related.
We know this because the case is simple, but it's also pretty easy to tell in real cases when looking at the conflict because every line is removed on one side and added again on the other.
By default, Git sees all of these lines as being changed, so it can't merge the files.
//////////////////////////
この例では、コンフリクトは空白文字が原因で起こっていました。例が簡単なのでそれが明確ですが、実際の場合でも見分けるのは簡単です。というのも、コンフリクトの内容が、一方で全行を削除しつつもう一方では全行を追加した形になっているからです。Git のデフォルトでは、これは「全行が変更された」と見なされ、マージは行えません。

The default merge strategy can take arguments though, and a few of them are about properly ignoring whitespace changes.
If you see that you have a lot of whitespace issues in a merge, you can simply abort it and do it again, this time with `-Xignore-all-space` or `-Xignore-space-change`.
The first option ignores whitespace **completely** when comparing lines, the second treats sequences of one or more whitespace characters as equivalent.
//////////////////////////
ただし、デフォルトのマージ戦略で指定できる引数には、空白文字を適切に除外できるものもあります。大量の空白文字が原因でマージがうまくいかない場合は、一度中止して最初からやり直してみましょう。その際は、`-Xignore-all-space` か `-Xignore-space-change` のオプションを使ってください。前者は既存の空白文字に関する変更を **すべて** 無視し、後者は2文字以上の空白文字が連続している場合にそれを同一であるとみなして処理します。

[source,console]
----
$ git merge -Xignore-space-change whitespace
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
----

//////////////////////////
Since in this case, the actual file changes were not conflicting, once we ignore the whitespace changes, everything merges just fine.
//////////////////////////
この例ではファイルの実際の変更にコンフリクトがないので、空白文字の変更を無視してしまえば、あとはすんなりとマージできます。

//////////////////////////
This is a lifesaver if you have someone on your team who likes to occasionally reformat everything from spaces to tabs or vice-versa.
//////////////////////////
チームのメンバーにスペースをタブに変えたがる（もしくはその反対）人がいたりすると、このオプションはきっと大助かりだと思います。

[[_manual_remerge]]
//////////////////////////
===== Manual File Re-merging
//////////////////////////
===== マージの手動再実行

//////////////////////////
Though Git handles whitespace pre-processing pretty well, there are other types of changes that perhaps Git can't handle automatically, but are scriptable fixes.
As an example, let's pretend that Git could not handle the whitespace change and we needed to do it by hand.
//////////////////////////
Git は空白文字を前もって上手に処理してくれます。ただし、自動で処理するのは難しいけれど、変更の内容によっては処理をスクリプトに落とし込める場合があります。ここでは例として、空白文字がうまく処理されず、手動でコンフリクトを解消することになったとしましょう。

//////////////////////////
What we really need to do is run the file we're trying to merge in through a `dos2unix` program before trying the actual file merge.
So how would we do that?
//////////////////////////
その場合、マージしようとしているファイルを前もって `dos2unix` プログラムで処理しておく必要があります。どうすればいいでしょうか。

//////////////////////////
First, we get into the merge conflict state.
Then we want to get copies of my version of the file, their version (from the branch we're merging in) and the common version (from where both sides branched off).
Then we want to fix up either their side or our side and re-try the merge again  for just this single file.
//////////////////////////
手順はこうです。まずはじめに、実際にコンフリクトを発生させます。次に、コンフリクトしているファイルを、自分たちの分・相手側（マージしようとしているブランチ）の分・共通（両方のブランチの共通の祖先）の分の3バージョン用意します。最後に、自分たちか相手側、どちらかのファイルを修正し、該当のファイル1つだけを改めてマージします。

//////////////////////////
Getting the three file versions is actually pretty easy.
Git stores all of these versions in the index under ``stages'' which each have numbers associated with them.
Stage 1 is the common ancestor, stage 2 is your version and stage 3 is from the `MERGE_HEAD`, the version you're merging in (``theirs'').
//////////////////////////
なお、この手順で使う3バージョンは簡単に用意できます。Git は、これらのバージョンを ``stages'' というインデックスに番号付きで保存してくれているのです。Stage 1 は共通の祖先、stage 2 は自分たちの分、Stage 3は `MERGE_HEAD` （マージしようとしている、``theirs'' にあたる）の分になります。

//////////////////////////
You can extract a copy of each of these versions of the conflicted file with the `git show` command and a special syntax.
//////////////////////////
コンフリクトが発生したファイルの3バージョンを用意するには、`git show` コマンドを以下のように指定して実行します。

[source,console]
----
$ git show :1:hello.rb > hello.common.rb
$ git show :2:hello.rb > hello.ours.rb
$ git show :3:hello.rb > hello.theirs.rb
----

//////////////////////////
If you want to get a little more hard core, you can also use the `ls-files -u` plumbing command to get the actual SHA-1s of the Git blobs for each of these files.
//////////////////////////
そんな簡単なの？と拍子抜けしたのなら、Git の配管コマンドである `ls-files -u` を使ってみましょう。各ファイルの blob の SHA-1 を表示してくれます。

[source,console]
----
$ git ls-files -u
100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1	hello.rb
100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2	hello.rb
100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3	hello.rb
----

//////////////////////////
The `:1:hello.rb` is just a shorthand for looking up that blob SHA-1.
//////////////////////////
このとおり、`:1:hello.rb` は blob の SHA を調べるための簡易記法です。

//////////////////////////
Now that we have the content of all three stages in our working directory, we can manually fix up theirs to fix the whitespace issue and re-merge the file with the little-known `git merge-file` command which does just that.
//////////////////////////
3バージョン分のデータを作業ディレクトリに取り出せたので、相手側のファイルにある空白文字の問題を解消して、マージを再実行してみましょう。マイナーなコマンドですが、まさにこういったときのために使える `git merge-file` というコマンドを用います。

[source,console]
----
$ dos2unix hello.theirs.rb
dos2unix: converting file hello.theirs.rb to Unix format ...

$ git merge-file -p \
    hello.ours.rb hello.common.rb hello.theirs.rb > hello.rb

$ git diff -b
diff --cc hello.rb
index 36c06c8,e85207e..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,8 -1,7 +1,8 @@@
  #! /usr/bin/env ruby

 +# prints out a greeting
  def hello
-   puts 'hello world'
+   puts 'hello mundo'
  end

  hello()
----

//////////////////////////
At this point we have nicely merged the file.
In fact, this actually works better than the `ignore-space-change` option because this actually fixes the whitespace changes before merge instead of simply ignoring them.
In the `ignore-space-change` merge, we actually ended up with a few lines with DOS line endings, making things mixed.
//////////////////////////
こうすれば、コンフリクトしたファイルをきれいにマージできます。この方法を使うと、空白文字の問題は無視されずにマージ前にきちんと解決されるので、`ignore-space-change` オプションを使うよりも便利です。実際、`ignore-space-change` でマージを行ったら改行コードが DOS の行が数行残っており、改行コードが混在した状態になってしまっていました。

//////////////////////////
If you want to get an idea before finalizing this commit about what was actually changed between one side or the other, you can ask `git diff` to compare what is in your working directory that you're about to commit as the result of the merge to any of these stages.
Let's go through them all.
//////////////////////////
なお、自分たち（もしくは相手側）のファイルがどのように変更されたかを、ここでの変更をコミットする前に確認したい場合は、`git diff` コマンドを使います。そうすれば、作業ディレクトリにあるコミット予定のファイルを、上述の3ステージと比較できるのです。実際にやってみましょう。

//////////////////////////
To compare your result to what you had in your branch before the merge, in other words, to see what the merge introduced, you can run `git diff --ours`
//////////////////////////
まず、マージ前のブランチの状態を手元の現状と比較する（マージが何をどう変更したのか確認する）には、`git diff --ours` を実行します。

[source,console]
----
$ git diff --ours
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index 36c06c8..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -2,7 +2,7 @@

 # prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()
----

//////////////////////////
So here we can easily see that what happened in our branch, what we're actually introducing to this file with this merge, is changing that single line.
//////////////////////////
そうすると、作業中のブランチがどう変更されたか（マージすることでこのファイルがどう変更されるか）がすぐわかります。この例では、変更されるのは1行だけです。

//////////////////////////
If we want to see how the result of the merge differed from what was on their side, you can run `git diff --theirs`.
In this and the following example, we have to use `-b` to strip out the whitespace because we're comparing it to what is in Git, not our cleaned up `hello.theirs.rb` file.
//////////////////////////
次に、相手側のファイルがマージ前後でどう変わったかを確認するには、`git diff --theirs` を使います。なお、この例と次の例では、空白文字を除外するために `-b` オプションを使用しています。これから比較するのは空白文字が処理済みの手元のファイル `hello.theirs.rb` ではなく、Git のデータベースに格納されているデータだからです。


[source,console]
----
$ git diff --theirs -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index e85207e..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello mundo'
 end
----

//////////////////////////
Finally, you can see how the file has changed from both sides with `git diff --base`.
//////////////////////////
そして、自分と相手、両側から変更を確認する場合は `git diff --base` を使いましょう。

[source,console]
----
$ git diff --base -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index ac51efd..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,8 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()
----

//////////////////////////
At this point we can use the `git clean` command to clear out the extra files we created to do the manual merge but no longer need.
//////////////////////////
最後に、マージを手動で行うために作成したファイルは `git clean` コマンドで削除してしまいましょう。必要になることはもうありません。

[source,console]
----
$ git clean -f
Removing hello.common.rb
Removing hello.ours.rb
Removing hello.theirs.rb
----

[[_checking_out_conflicts]]
//////////////////////////
===== Checking Out Conflicts
//////////////////////////
===== コンフリクトのチェックアウト

//////////////////////////
Perhaps we're not happy with the resolution at this point for some reason, or maybe manually editing one or both sides still didn't work well and we need more context.
//////////////////////////
ここで、さきほど試したコンフリクトの解決方法があまりよくなかった、もしくはマージ対象の一方（あるいは両方）を編集してもコンフリクトをうまく解消できず、これまでの流れを詳しく把握する必要が生じたとします。


//////////////////////////
Let's change up the example a little.
For this example, we have two longer lived branches that each have a few commits in them but create a legitimate content conflict when merged.
//////////////////////////
これを解説するには、先程の例を少し変更しておくほうがいいでしょう。今回は両方のブランチそれぞれにコミットが数回なされており、かつマージ時にはコンフリクトが発生するような状態だと仮定します。

[source,console]
----
$ git log --graph --oneline --decorate --all
* f1270f7 (HEAD, master) update README
* 9af9d3b add a README
* 694971d update phrase to hola world
| * e3eb223 (mundo) add more tests
| * 7cff591 add testing script
| * c3ffff1 changed text to hello mundo
|/
* b7dcc89 initial hello world code
----

//////////////////////////
We now have three unique commits that live only on the `master` branch and three others that live on the `mundo` branch.
If we try to merge the `mundo` branch in, we get a conflict.
//////////////////////////
`master` ブランチにしかないコミットが3つあり、`mundo` ブランチにしかないコミットも3つある、という状態です。ここで `mundo` ブランチをマージすれば、コンフリクトが発生してしまいます。

[source,console]
----
$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.
----

//////////////////////////
We would like to see what the merge conflict is.
If we open up the file, we'll see something like this:
//////////////////////////
どのようなコンフリクトが発生したのか確認しておきましょう。ファイルを開いてみると、以下の様な状態になっていました。

[source,ruby]
----
#! /usr/bin/env ruby

def hello
<<<<<<< HEAD
  puts 'hola world'
=======
  puts 'hello mundo'
>>>>>>> mundo
end

hello()
----

//////////////////////////
Both sides of the merge added content to this file, but some of the commits modified the file in the same place that caused this conflict.
//////////////////////////
マージ対象の両サイドで同じファイルの同じ箇所に違う変更を加えた結果、コンフリクトが発生してしまったことがわかります。

//////////////////////////
Let's explore a couple of tools that you now have at your disposal to determine how this conflict came to be.
Perhaps it's not obvious how exactly you should fix this conflict.
You need more context.
//////////////////////////
こういった場合に使える、コンフリクトの発生原因を確認できるツールを紹介します。コンフリクトをどう解消すればいいかが明確だとは限りません。そういったときは、経緯を把握する必要もあるはずです。

//////////////////////////
One helpful tool is `git checkout` with the `--conflict' option.
This will re-checkout the file again and replace the merge conflict markers.
This can be useful if you want to reset the markers and try to resolve them again.
//////////////////////////
まず1つめは、`git checkout` コマンドの `--conflict` オプションです。これを実行すると、指定したファイルをもう一度チェックアウトし、コンフリクトマーカーを書きなおします。コンフリクトを手で直していてうまくいかず、最初からやり直すためにリセットしたいときに便利です。

//////////////////////////
You can pass `--conflict` either `diff3` or `merge` (which is the default).
If you pass it `diff3`, Git will use a slightly different version of conflict markers, not only giving you the ``ours'' and ``theirs'' versions, but also the ``base'' version inline to give you more context.
//////////////////////////
`--conflict` オプションには `diff3` か `merge` が指定できます（デフォルトは `merge`）。前者を指定すると、コンフリクトマーカーが少し変わってきます。通常のマーカーである ``ours'' と ``theirs'' に加え、``base'' も表示されるのです。より詳しく状況がわかると思います。

[source,console]
----
$ git checkout --conflict=diff3 hello.rb
----

//////////////////////////
Once we run that, the file will look like this instead:
//////////////////////////
これを実行すると、マーカーはいつもとは違い以下のようになるはずです。

[source,ruby]
----
#! /usr/bin/env ruby

def hello
<<<<<<< ours
  puts 'hola world'
||||||| base
  puts 'hello world'
=======
  puts 'hello mundo'
>>>>>>> theirs
end

hello()
----

//////////////////////////
If you like this format, you can set it as the default for future merge conflicts by setting the `merge.conflictstyle` setting to `diff3`.
//////////////////////////
これをコンフリクトマーカーのデフォルトにすることもできます。この表示の方が好みであれば、設定項目 `merge.conflictstyle` を `diff3` に変更してみましょう。

[source,console]
----
$ git config --global merge.conflictstyle diff3
----

//////////////////////////
The `git checkout` command can also take `--ours` and `--theirs` options, which can be a really fast way of just choosing either one side or the other without merging things at all.
//////////////////////////
`git checkout` コマンドには `--ours` や `--theirs` オプションを指定することもできます。これを使うと、何かをマージする代わりに、どちらか一方を選択して簡単にチェックアウトできます。

//////////////////////////
This can be particularly useful for conflicts of binary files where you can simply choose one side, or where you only want to merge certain files in from another branch - you can do the merge and then checkout certain files from one side or the other before committing.
//////////////////////////
これは、バイナリデータのコンフリクトを解消するとき（使いたい方を選べばよい）や、他のブランチから特定のファイルを取り込みたいときに便利でしょう。後者であれば、マージコマンドを実行してから該当のファイルを `--ours` か `--theirs` を指定してチェックアウトし、コミットしてください。

[[_merge_log]]
//////////////////////////
===== Merge Log
//////////////////////////
===== マージの履歴

//////////////////////////
Another useful tool when resolving merge conflicts is `git log`.
This can help you get context on what may have contributed to the conflicts.
Reviewing a little bit of history to remember why two lines of development were touching the same area of code can be really helpful sometimes.
//////////////////////////
もう一つ、コンフリクトの解決に使える便利なツールが `git log` です。どういった流れでコンフリクトが発生したのかを追跡するときに使えます。というのも、歴史を少し紐解いてみると、平行して進行していた2つの開発作業がなぜコードの同じ部分を編集するに至ったか、その理由を思い出せたりするからです。

//////////////////////////
To get a full list of all of the unique commits that were included in either branch involved in this merge, we can use the ``triple dot'' syntax that we learned in <<_triple_dot>>.
//////////////////////////
マージ対象のブランチに含まれるコミットを重複分を除いて表示させるには、<<_triple_dot>> で触れた「トリプルドット」記法を使います。

[source,console]
----
$ git log --oneline --left-right HEAD...MERGE_HEAD
< f1270f7 update README
< 9af9d3b add a README
< 694971d update phrase to hola world
> e3eb223 add more tests
> 7cff591 add testing script
> c3ffff1 changed text to hello mundo
----

//////////////////////////
That's a nice list of the six total commits involved, as well as which line of development each commit was on.
//////////////////////////
この例では、全部で6コミットがわかりやすい状態でリスト表示されています。それぞれのコミットがどちらのブランチのものかもわかるようになっています。

//////////////////////////
We can further simplify this though to give us much more specific context.
If we add the `--merge` option to `git log`, it will only show the commits in either side of the  merge that touch a file that's currently conflicted.
//////////////////////////
また、より細かく流れを把握するために、表示内容を絞り込むこともできます。`git log` コマンドの `--merge` オプションを使うと、表示されるのはコンフリクトが発生しているファイルを編集したコミットだけになるのです。

[source,console]
----
$ git log --oneline --left-right --merge
< 694971d update phrase to hola world
> c3ffff1 changed text to hello mundo
----

//////////////////////////
If you run that with the `-p` option instead, you get just the diffs to the file that ended up in conflict.
This can be **really** helpful in quickly giving you the context you need to help understand why something conflicts and how to more intelligently resolve it.
//////////////////////////
また、このコマンドに `-p` オプションを追加すると、表示される内容がコンフリクトしているファイルの差分だけになります。コンフリクトの原因を把握して賢明な方法でそれを解消するために、必要な背景や経緯をすばやく理解したいときに **とても** 役に立つでしょう。

//////////////////////////
===== Combined Diff Format
//////////////////////////
===== Combined Diff 形式

//////////////////////////
Since Git stages any merge results that are successful, when you run `git diff` while in a conflicted merge state, you only get what is currently still in conflict.
This can be helpful to see what you still have to resolve.
//////////////////////////
Git でマージを行うと、うまくマージされた内容はインデックスに追加されます。つまり、マージのコンフリクトが残っている状態で `git diff` を実行すると、コンフリクトの内容だけが表示されることになります。これを使えば、残ったコンフリクトだけを確認できます。

//////////////////////////
When you run `git diff` directly after a merge conflict, it will give you information in a rather unique diff output format.
//////////////////////////
実際に、マージのコンフリクトが発生した直後に `git diff` を実行してみましょう。特徴的な diff 形式で差分が表示されます。

[source,console]
----
$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,11 @@@
  #! /usr/bin/env ruby

  def hello
++<<<<<<< HEAD
 +  puts 'hola world'
++=======
+   puts 'hello mundo'
++>>>>>>> mundo
  end

  hello()
----

//////////////////////////
The format is called ``Combined Diff'' and gives you two columns of data next to each line.
The first column shows you if that line is different (added or removed) between the ``ours'' branch and the file in your working directory and the second column does the same between the ``theirs'' branch and your working directory copy.
//////////////////////////
これは ``Combined Diff'' という形式で、各行の行頭2文字を使って関連情報を表示します。具体的には、作業ディレクトリの内容とマージ元のブランチ（「ours」）の内容に差分があれば1文字目を、作業ディレクトリとマージの相手側のブランチ（「theirs」）に差分があれば2文字目が使われます。

//////////////////////////
So in that example you can see that the `<<<<<<<` and `>>>>>>>` lines are in the working copy but were not in either side of the merge.
This makes sense because the merge tool stuck them in there for our context, but we're expected to remove them.
//////////////////////////
この例では、作業ディレクトリには存在する `<<<<<<<` と `>>>>>>>` の行が、マージ対象のブランチどちらにも存在していないことがわかります。それもそのはず、これらの行はマージによって挿入されたからです。差分をわかりやすくするために挿入されたこれらの行は、手動で削除する必要があります。

//////////////////////////
If we resolve the conflict and run `git diff` again, we'll see the same thing, but it's a little more useful.
//////////////////////////
このコンフリクトを解消してから `git diff` を実行しても同じような内容が表示されますが、この場合はもう少し気の利いた内容になります。

[source,console]
----
$ vim hello.rb
$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()
----

//////////////////////////
This shows us that ``hola world'' was in our side but not in the working copy, that ``hello mundo'' was in their side but not in the working copy and finally that ``hola mundo'' was not in either side but is now in the working copy.
This can be useful to review before committing the resolution.
//////////////////////////
ここから読み取れるのは、``hola world'' はマージ元のブランチにはあって作業ディレクトリには存在せず、``hello mundo'' はマージ対象のブランチにはあって作業ディレクトリには存在していないこと、更に ``hola mundo'' はマージ対象の両ブランチには存在しないけれど作業ディレクトリには存在していることです。これを使えば、コンフリクトをどのように解決したか、マージする前に確認できます。

//////////////////////////
You can also get this from the `git log` for any merge after the fact to see how something was resolved after the fact.
Git will output this format if you run `git show` on a merge commit, or if you add a `--cc` option to a `git log -p` (which by default only shows patches for non-merge commits).
//////////////////////////
`git log` を使っても、同じ内容を表示させられます。マージの際にどういった変更がなされたのか、後々になって確認する際に便利です。`git show` コマンドをマージコミットに対して実行した場合か、`git log -p` （デフォルトではマージコミット以外のコミットの内容をパッチ形式で表示）に `--cc` オプションを付与した場合、この形式の差分が出力されます。


[source,console]
----
$ git log --cc -p -1
commit 14f41939956d80b9e17bb8721354c33f8d5b5a79
Merge: f1270f7 e3eb223
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Sep 19 18:14:49 2014 +0200

    Merge branch 'mundo'

    Conflicts:
        hello.rb

diff --cc hello.rb
index 0399cd5,59727f0..e1d0799
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()
----

[[_undoing_merges]]
//////////////////////////
==== Undoing Merges
//////////////////////////
==== マージの取消

//////////////////////////
Now that you know how to create a merge commit, you'll probably make some by mistake.
One of the great things about working with Git is that it's okay to make mistakes, because it's possible (and in many cases easy) to fix them.
//////////////////////////
マージの方法がわかったということは、間違ってマージしてしまう可能性も出てきた、ということになります。
Git を使うことの利点は、間違ってもいい、ということです。というのも、（大抵は簡単に）修正できるからです。

//////////////////////////
Merge commits are no different.
Let's say you started work on a topic branch, accidentally merged it into `master`, and now your commit history looks like this:
//////////////////////////
マージコミットももちろん修正可能です。
例えば、トピックブランチで作業を開始し、間違ってそのブランチを `master` にマージしてしまったとしましょう。コミット履歴は以下のようになっているはずです。

//////////////////////////
.Accidental merge commit
image::images/undomerge-start.png[Accidental merge commit.]
//////////////////////////
.間違って作成したマージコミット
image::images/undomerge-start.png[間違って作成したマージコミット]

//////////////////////////
There are two ways to approach this problem, depending on what your desired outcome is.
//////////////////////////
この状況を修正するには2通りのやり方があります。どのように修正したいかに応じて使い分けましょう。

//////////////////////////
===== Fix the references
//////////////////////////
===== 参照の修正

//////////////////////////
If the unwanted merge commit only exists on your local repository, the easiest and best solution is to move the branches so that they point where you want them to.
In most cases, if you follow the errant `git merge` with `git reset --hard HEAD~`, this will reset the branch pointers so they look like this:
//////////////////////////
不要なマージコミットをまだプッシュしていないのなら、ブランチが指し示すコミットを変更してしまうのが一番簡単な解決方法です。
大半の場合、間違って実行した `git merge` の後に `git reset --hard HEAD~` を実行すれば、ブランチのポインタがリセットされます。実行結果は以下のようになるでしょう。

//////////////////////////
.History after `git reset --hard HEAD~`
image::images/undomerge-reset.png[History after `git reset --hard HEAD~`.]
//////////////////////////
.`git reset --hard HEAD~` 実行後の歴史
image::images/undomerge-reset.png[`git reset --hard HEAD~` 実行後の歴史]

//////////////////////////
We covered `reset` back in <<_git_reset>>, so it shouldn't be too hard to figure out what's going on here.
Here's a quick refresher: `reset --hard` usually goes through three steps:
//////////////////////////
`reset` コマンドについては <<_git_reset>> で触れましたので、ここで何が起こっているか、理解するのは難しいことではないと思います。
念のためおさらいしておきましょう。`reset --hard` を実行すると、通常は以下の処理が走ります。

//////////////////////////
. Move the branch HEAD points to.
  In this case, we want to move `master` to where it was before the merge commit (`C6`).
. Make the index look like HEAD.
. Make the working directory look like the index.
//////////////////////////
. HEAD が指し示すブランチを移動する
  この例では、マージコミット (`C6`) が作成される前に `master` が指していたところまで戻します。
. インデックスの内容を HEAD と同じにする
. 作業ディレクトリの内容をインデックスと同じにする

//////////////////////////
The downside of this approach is that it's rewriting history, which can be problematic with a shared repository.
Check out <<_rebase_peril>> for more on what can happen; the short version is that if other people have the commits you're rewriting, you should probably avoid `reset`.
This approach also won't work if any other commits have been created since the merge; moving the refs would effectively lose those changes.
//////////////////////////
この方法の欠点は、歴史を書き換えてしまう点です。共有リポジトリで作業していると、問題視される場合があります。
書き換えようとしているコミットをほかの人たちもプルしてしまっている場合は、`reset` は使わないほうが無難でしょう。理由については <<_rebase_peril>> を確認してみてください。
また、新たなコミットがマージ以後に追加されている場合は、この方法はうまくいきません。参照を移動してしまうと、追加された内容を削除することになってしまうからです。

[[_reverse_commit]]
//////////////////////////
===== Reverse the commit
//////////////////////////
===== コミットの打ち消し

//////////////////////////
If moving the branch pointers around isn't going to work for you, Git gives you the option of making a new commit which undoes all the changes from an existing one.
Git calls this operation a ``revert'', and in this particular scenario, you'd invoke it like this:
//////////////////////////
ブランチのポインタを動かすという上述の方法が機能しない場合、既存のコミットの内容を打ち消す新しいコミットを作ることもできます。
これは ``revert'' と呼ばれる操作で、今回の例では以下のようにすると呼び出せます。

[source,console]
----
$ git revert -m 1 HEAD
[master b1d8379] Revert "Merge branch 'topic'"
----

//////////////////////////
The `-m 1` flag indicates which parent is the ``mainline'' and should be kept.
When you invoke a merge into `HEAD` (`git merge topic`), the new commit has two parents: the first one is `HEAD` (`C6`), and the second is the tip of the branch being merged in (`C4`).
In this case, we want to undo all the changes introduced by merging in parent #2 (`C4`), while keeping all the content from parent #1 (`C6`).
//////////////////////////
`-m 1` オプションで、保持すべき「メイン」の親がどれであるかを指定します。
`HEAD` に対するマージ（`git merge topic`）を実行すると、マージコミットには2つの親ができます。`HEAD` (`C6`) と マージされるブランチの最新コミット (`C4`) です。
この例では、第2の親 (`C4`) をマージしたことで生じた変更をすべて打ち消しつつ、第1の親 (`C6`) の内容は保持したままにしてみます。

//////////////////////////
The history with the revert commit looks like this:
//////////////////////////
revert のコミットを含む歴史は以下のようになります。

//////////////////////////
.History after `git revert -m 1`
image::images/undomerge-revert.png[History after `git revert -m 1`.]
//////////////////////////
.`git revert -m 1` の後の歴史
image::images/undomerge-revert.png[`git revert -m 1` の後の歴史]

//////////////////////////
The new commit `^M` has exactly the same contents as `C6`, so starting from here it's as if the merge never happened, except that the now-unmerged commits are still in `HEAD`'s history.
Git will get confused if you try to merge `topic` into `master` again:
//////////////////////////
新しく作成されたコミット `^M` の内容はコミット `C6` とまったく同じですので、歴史を今後振り返ると、マージなど一度も実施されていないかのように思えます。ただし、実際のところは `HEAD` の方の歴史にはマージされていないコミットが残ったままになってしまいます。
この状態で `topic` を `master` にマージしようとすると、Git は状況を正確に判断できません。

[source,console]
----
$ git merge topic
Already up-to-date.
----

//////////////////////////
There's nothing in `topic` that isn't already reachable from `master`.
What's worse, if you add work to `topic` and merge again, Git will only bring in the changes _since_ the reverted merge:
//////////////////////////
これは、`topic` ブランチにあるものは `master` ブランチにもすべて存在している、という状態です。
更に悪いことに、この状態の `topic` ブランチにコミットを追加してマージを行うと、revert されたマージ _後_ の変更だけが取り込まれることになります。

//////////////////////////
.History with a bad merge
image::images/undomerge-revert2.png[History with a bad merge.]
//////////////////////////
.よくないマージを含む歴史
image::images/undomerge-revert2.png[よくないマージを含む歴史]

//////////////////////////
The best way around this is to un-revert the original merge, since now you want to bring in the changes that were reverted out, *then* create a new merge commit:
//////////////////////////
ここでは revert してしまった変更を取り戻したいわけですから、revert 済みの古いマージコミットをもう一度 revert し、 *そのうえで* 改めてマージするのが一番いいでしょう。

[source,console]
----
$ git revert ^M
[master 09f0126] Revert "Revert "Merge branch 'topic'""
$ git merge topic
----

//////////////////////////
.History after re-merging a reverted merge
image::images/undomerge-revert3.png[History after re-merging a reverted merge.]
//////////////////////////
.revert 済みのマージコミットを再度マージした後の歴史
image::images/undomerge-revert3.png[revert 済みのマージコミットを再度マージした後の歴史]

//////////////////////////
In this example, `M` and `^M` cancel out.
`^^M` effectively merges in the changes from `C3` and `C4`, and `C8` merges in the changes from `C7`, so now `topic` is fully merged.
//////////////////////////
そうすると、`M` と `^M` が互いを打ち消します。
`^^M` によって `C3` と `C4` の変更が取り込まれたことになりますし、`C8` のマージコミットによって `C7` が取り込まれます。これでようやっと、`topic` ブランチはすべてマージされました。

//////////////////////////
==== Other Types of Merges
//////////////////////////
==== 他のマージ手法

//////////////////////////
So far we've covered the normal merge of two branches, normally handled with what is called the ``recursive'' strategy of merging.
There are other ways to merge branches together however.
Let's cover a few of them quickly.
//////////////////////////
ここまでは2つのブランチをマージする通常の手法を見てきました。一般的には、「再帰」 と呼ばれるマージ戦略によって処理されている手法です。これ以外にもブランチをマージする手法がありますので、いくつかをざっと紹介します。

//////////////////////////
===== Our or Theirs Preference
//////////////////////////
===== Our か Theirs の選択

//////////////////////////
First of all, there is another useful thing we can do with the normal ``recursive'' mode of merging.
We've already seen the `ignore-all-space` and `ignore-space-change` options which are passed with a `-X` but we can also tell Git to favor one side or the other when it sees a conflict.
//////////////////////////
1つめに紹介するのは、マージの「再帰」モードで使える便利なオプションです。`-X` と組み合わせて使う `ignore-all-space` や `ignore-space-change` といったオプションは既に紹介しました。Git ではそれ以外にも、コンフリクトが発生したときにマージ対象のどちらを優先するかを指定できます。

//////////////////////////
By default, when Git sees a conflict between two branches being merged, it will add merge conflict markers into your code and mark the file as conflicted and let you resolve it.
If you would prefer for Git to simply choose a specific side and ignore the other side instead of letting you manually merge the conflict, you can pass the `merge` command either a `-Xours` or `-Xtheirs`.
//////////////////////////
Git のデフォルトでは、マージしようとしているブランチ間でコンフリクトがある場合、コードにはコンフリクトを示すマーカーが挿入され、該当ファイルはコンフリクト扱いとなり、手動で解決することになります。そうではなく、マージ対象のブランチどちらかを優先して自動でコンフリクトを解消して欲しいとしましょう。その場合、`merge` コマンドに `-Xours` か `-Xtheirs` オプションを指定できます。

//////////////////////////
If Git sees this, it will not add conflict markers.
Any differences that are mergeable, it will merge.
Any differences that conflict, it will simply choose the side you specify in whole, including binary files.
//////////////////////////
これらが指定されると、コンフリクトを示すマーカーは追加されません。マージ可能な差異は通常どおりマージされ、コンフリクトが発生する差異については指定された側のブランチの内容が採用されます。これはバイナリデータについても同様です。

//////////////////////////
If we go back to the ``hello world'' example we were using before, we can see that merging in our branch causes conflicts.
//////////////////////////
以前使った ``hello world'' の例で確認してみましょう。作ったブランチをマージしようとするとコンフリクトが発生してしまいます。

[source,console]
----
$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Resolved 'hello.rb' using previous resolution.
Automatic merge failed; fix conflicts and then commit the result.
----

//////////////////////////
However if we run it with `-Xours` or `-Xtheirs` it does not.
//////////////////////////
ですが、`-Xours` か `-Xtheirs` を指定してマージすると、コンフリクトは発生しません。

[source,console]
----
$ git merge -Xours mundo
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 test.sh  | 2 ++
 2 files changed, 3 insertions(+), 1 deletion(-)
 create mode 100644 test.sh
----

//////////////////////////
In that case, instead of getting conflict markers in the file with ``hello mundo'' on one side and ``hola world'' on the other, it will simply pick ``hola world''.
However, all the other non-conflicting changes on that branch are merged successfully in.
//////////////////////////
そうすると、``hello mundo'' と ``hola world'' でコンフリクトが発生している部分にマーカーを挿入する代わりに、``hola world'' の方が採用されます。そして、その場合でも、マージされる側のブランチにあるコンフリクトしない変更についてはすべてマージされます。

//////////////////////////
This option can also be passed to the `git merge-file` command we saw earlier by running something like `git merge-file --ours` for individual file merges.
//////////////////////////
このオプションは、既に紹介した `git merge-file` コマンドでも使用可能です。`git merge-file --ours` のような形で実行すれば、ファイルを個別にマージするときに使えます。

//////////////////////////
If you want to do something like this but not have Git even try to merge changes from the other side in, there is a more draconian option, which is the ``ours'' merge _strategy_.
This is different from the ``ours'' recursive merge _option_.
//////////////////////////
また、同じようなことをしたいけれど、マージされる側の変更点は何一つ取り込みたくない、というようなことになったとしましょう。その場合、より強力な選択肢として ``ours'' というマージ _戦略_ が使えます。これは ``ours'' を使って行う再帰的なマージ用の _オプション_ とは異なります。

//////////////////////////
This will basically do a fake merge.
It will record a new merge commit with both branches as parents, but it will not even look at the branch you're merging in.
It will simply record as the result of the merge the exact code in your current branch.
//////////////////////////
ではその戦略が何をするかというと、偽のマージが実行されるのです。マージ対象の両ブランチを親としたマージコミットが新たに作成されますが、マージされる側のブランチの内容については一切考慮されません。現在いるブランチの内容が、マージの結果としてそのままそっくり記録されます。

[source,console]
----
$ git merge -s ours mundo
Merge made by the 'ours' strategy.
$ git diff HEAD HEAD~
$
----

//////////////////////////
You can see that there is no difference between the branch we were on and the result of the merge.
//////////////////////////
このとおり、マージ結果とマージ直前の状態に一切変更点がないことがわかります。

//////////////////////////
This can often be useful to basically trick Git into thinking that a branch is already merged when doing a merge later on.
For example, say you branched off a `release` branch and have done some work on it that you will want to merge back into your `master` branch at some point.
In the meantime some bugfix on `master` needs to be backported into your `release` branch.
You can merge the bugfix branch into the `release` branch and also `merge -s ours` the same branch into your `master` branch (even though the fix is already there) so when you later merge the `release` branch again, there are no conflicts from the bugfix.
//////////////////////////
これが役に立つのは、後々になってマージを行う際に Git を勘違いさせて、ブランチをマージ済みとして取り扱わせたい場合です。具体例を挙げて説明しましょう。「リリース」ブランチを作成して作業を進めているとします。そのブランチは、いずれ ``master'' ブランチにマージするつもりです。ここで、``master'' 上で行われたバグ修正を `release` ブランチにも取り込む必要が出てきました。そのためには、まずはバグ修正のブランチを `release` ブランチにマージし、続いて `merge -s ours` コマンドで同じブランチを `master` ブランチにもマージします（修正は既に取り込まれていますが、あえて実施します）。そうしておけば、`release` ブランチをマージする際に、バグ修正のブランチが原因でコンフリクトが発生することはありません。

include::subtree-merges.asc[]
