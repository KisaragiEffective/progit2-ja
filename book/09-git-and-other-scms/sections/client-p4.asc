//////////////////////////
==== Git and Perforce
//////////////////////////
==== Git と Perforce

(((Interoperation with other VCSs, Perforce)))
(((Perforce)))
//////////////////////////
Perforce is a very popular version-control system in corporate environments.
It's been around since 1995, which makes it the oldest system covered in this chapter.
As such, it's designed with the constraints of its day; it assumes you're always connected to a single central server, and only one version is kept on the local disk.
To be sure, its features and constraints are well-suited to several specific problems, but there are lots of projects using Perforce where Git would actually work better.
//////////////////////////
Perforce は企業内では非常によく使われているバージョン管理システムです。
Perforce が登場したのは 1995 年で、この章で扱う中ではもっとも古いシステムです。
そしてその言葉通り、Perforce は当時の制約に合わせて設計されています。単一の中央サーバへの常時接続を仮定しており、またローカルディスクに保存しておけるバージョンは一つだけです。
確かに、Perforce の機能と制約は、ある特定の問題にはうまく適合します。しかし、実際には Git の方が上手くいくにも関わらず、 Perforce を使用しているというプロジェクトも数多くあります。

//////////////////////////
There are two options if you'd like to mix your use of Perforce and Git.
The first one we'll cover is the ``Git Fusion'' bridge from the makers of Perforce, which lets you expose subtrees of your Perforce depot as read-write Git repositories.
The second is git-p4, a client-side bridge that lets you use Git as a Perforce client, without requiring any reconfiguration of the Perforce server.
//////////////////////////
Perforce と Git を混在して使用したい場合、2通りの選択肢があります。
1つ目に取り上げるのは Perforce の開発元から出ている ``Git Fusion'' ブリッジです。これは、 Perforce ディポのサブツリーを読み書き可能な Git リポジトリとして公開させるものです。
2つ目はクライアントサイドのブリッジである git-p4 です。これは Git を Perforce のクライアントとして使用できるようにするもので、 Perforce サーバの設定を変更することなく使用できます。

[[r_p4_git_fusion]]
===== Git Fusion

(((Perforce, Git Fusion)))
//////////////////////////
Perforce provides a product called Git Fusion (available at http://www.perforce.com/git-fusion[]), which synchronizes a Perforce server with Git repositories on the server side.
//////////////////////////
Perforce は Git Fusion という製品を提供しています（ http://www.perforce.com/git-fusion[] から入手可能）。これは、サーバサイドで Perforce サーバと Git リポジトリとを同期させます。

//////////////////////////
====== Setting Up
//////////////////////////
====== セットアップ

//////////////////////////
For our examples, we'll be using the easiest installation method for Git Fusion, which is downloading a virtual machine that runs the Perforce daemon and Git Fusion.
You can get the virtual machine image from http://www.perforce.com/downloads/Perforce/20-User[], and once it's finished downloading, import it into your favorite virtualization software (we'll use VirtualBox).
//////////////////////////
本書の例では、 Git Fusion のもっとも簡単なインストール法として、仮想マシンをダウンロードし、 Perforce デーモンと Git Fusion をその上で実行する方法をとります。
仮想マシンイメージは http://www.perforce.com/downloads/Perforce/20-User[] から入手できます。ダウンロードが完了したら、お好みの仮想ソフトへインポートします（本書では VirtualBox を使用します）。

//////////////////////////
Upon first starting the machine, it asks you to customize the password for three Linux users (`root`, `perforce`, and `git`), and provide an instance name, which can be used to distinguish this installation from others on the same network.
When that has all completed, you'll see this:
//////////////////////////
仮想マシンの初回起動時には、3つの Linux ユーザ（ `root`、 `perforce` 、および `git` ）のパスワードを設定するよう要求されます。また、同じネットワーク上の他の仮想マシンとの区別のため、インスタンス名を決めるよう要求されます。
これらすべてが完了したら、次の画面が表示されるはずです。

//////////////////////////
.The Git Fusion virtual machine boot screen.
image::images/git-fusion-boot.png[The Git Fusion virtual machine boot screen.]
//////////////////////////
.Git Fusion 仮想マシンのブート画面
image::images/git-fusion-boot.png[Git Fusion 仮想マシンのブート画面]

//////////////////////////
You should take note of the IP address that's shown here, we'll be using it later on.
Next, we'll create a Perforce user.
Select the ``Login'' option at the bottom and press enter (or SSH to the machine), and log in as `root`.
Then use these commands to create a user:
//////////////////////////
ここで表示されるIPアドレスは、後で使用するので、メモしておいてください。
次に、 Perforce ユーザを作成します。
下部にある ``Login'' オプションを選択肢、Enterキーを押下し（または仮想マシンへSSHで接続し）、 `root` としてログインします。
続けて、次のコマンドでユーザを作成します。

[source,console]
----
$ p4 -p localhost:1666 -u super user -f john
$ p4 -p localhost:1666 -u john passwd
$ exit
----

//////////////////////////
The first one will open a VI editor to customize the user, but you can accept the defaults by typing `:wq` and hitting enter.
The second one will prompt you to enter a password twice.
That's all we need to do with a shell prompt, so exit out of the session.
//////////////////////////
1つめのコマンドは、ユーザのカスタマイズのため VI エディタを起動しますが、 `:wq` に続けて Enter を入力すれば、デフォルト設定のまま利用することもできます。
2つめのコマンドは、パスワードを2度入力するようプロンプトを表示します。
シェルプロンプトで行う必要のある作業はこれで全部ですので、セッションを終了します。

//////////////////////////
The next thing you'll need to do to follow along is to tell Git not to verify SSL certificates.
The Git Fusion image comes with a certificate, but it's for a domain that won't match your virtual machine's IP address, so Git will reject the HTTPS connection.
If this is going to be a permanent installation, consult the Perforce Git Fusion manual to install a different certificate; for our example purposes, this will suffice:
//////////////////////////
次に手順に従って行う必要があるのは、Git が SSL 証明書を検証しないようにすることです。
Git Fusion の仮想マシンイメージには証明書が同梱されていますが、これはあなたの仮想マシンのIPアドレスとは合わないであろうドメインのものなので、 Git は HTTPS 接続を拒否してしまいます。
今回インストールした環境を今後も使い続けるつもりなら、 Perforce Git Fusion マニュアルを参考に、個別の証明書をインストールしてください。本書で例を示すだけの用途なら、以下で十分です。 

[source,console]
----
$ export GIT_SSL_NO_VERIFY=true
----

//////////////////////////
Now we can test that everything is working.
//////////////////////////
これで、すべてが動作しているかテストできるようになりました。

[source,console]
----
$ git clone https://10.0.1.254/Talkhouse
Cloning into 'Talkhouse'...
Username for 'https://10.0.1.254': john
Password for 'https://john@10.0.1.254':
remote: Counting objects: 630, done.
remote: Compressing objects: 100% (581/581), done.
remote: Total 630 (delta 172), reused 0 (delta 0)
Receiving objects: 100% (630/630), 1.22 MiB | 0 bytes/s, done.
Resolving deltas: 100% (172/172), done.
Checking connectivity... done.
----

//////////////////////////
The virtual-machine image comes equipped with a sample project that you can clone.
Here we're cloning over HTTPS, with the `john` user that we created above; Git asks for credentials for this connection, but the credential cache will allow us to skip this step for any subsequent requests.
//////////////////////////
仮想マシンイメージには、クローンできるサンプルプロジェクトが同梱されています。
ここでは、上で作成したユーザ `john` を使用し、 HTTPS 経由でクローンしています。今回の接続時には認証情報を要求されますが、以降のリクエストでは Git の認証情報キャッシュが働くので、このステップは省略できます。

//////////////////////////
====== Fusion Configuration
//////////////////////////
====== Fusion の設定

//////////////////////////
Once you've got Git Fusion installed, you'll want to tweak the configuration.
This is actually fairly easy to do using your favorite Perforce client; just map the `//.git-fusion` directory on the Perforce server into your workspace.
The file structure looks like this:
//////////////////////////
Git Fusion をインストールし終わったら、設定を調整したいことと思います。
設定の変更は、お好きな Perforce クライアントを使用して、実際非常に簡単に行えます。Perforce サーバの `//.git-fusion` ディレクトリをワークスペースにマップするだけです。
ファイル構造は次のようになっています。

[source,console]
----
$ tree
.
├── objects
│   ├── repos
│   │   └── [...]
│   └── trees
│       └── [...]
│
├── p4gf_config
├── repos
│   └── Talkhouse
│       └── p4gf_config
└── users
    └── p4gf_usermap

498 directories, 287 files
----

//////////////////////////
The `objects` directory is used internally by Git Fusion to map Perforce objects to Git and vice versa, you won't have to mess with anything in there.
There's a global `p4gf_config` file in this directory, as well as one for each repository – these are the configuration files that determine how Git Fusion behaves.
Let's take a look at the file in the root:
//////////////////////////
`objects` ディレクトリは Perforce のオブジェクトを Git へ対応付ける（逆も同様）ために Git Fusion が内部的に使用しているもので、この内容に触れる必要はありません。
このディレクトリにはグローバルな `p4gf_config` 設定ファイルがあります。また、このファイルは各リポジトリにも一つずつあります – これらは、 Git Fusion の動作を決定する設定ファイルです。
ルートディレクトリにあるファイルを見てみましょう。

[source,ini]
----
[repo-creation]
charset = utf8

[git-to-perforce]
change-owner = author
enable-git-branch-creation = yes
enable-swarm-reviews = yes
enable-git-merge-commits = yes
enable-git-submodules = yes
preflight-commit = none
ignore-author-permissions = no
read-permission-check = none
git-merge-avoidance-after-change-num = 12107

[perforce-to-git]
http-url = none
ssh-url = none

[@features]
imports = False
chunked-push = False
matrix2 = False
parallel-push = False

[authentication]
email-case-sensitivity = no
----

//////////////////////////
We won't go into the meanings of these flags here, but note that this is just an INI-formatted text file, much like Git uses for configuration.
This file specifies the global options, which can then be overridden by repository-specific configuration files, like `repos/Talkhouse/p4gf_config`.
If you open this file, you'll see a `[@repo]` section with some settings that are different from the global defaults.
You'll also see sections that look like this:
//////////////////////////
ここでは各フラグの意味については説明しませんが、このファイルが、 Git の設定ファイル同様、単なる INI ファイル形式のテキストファイルであるという点は明記しておきます。
このファイルではグローバルなオプションを設定しています。これらの設定は `repos/Talkhouse/p4gf_config` などのリポジトリ固有の設定で上書きできます。 
このファイルを開くと、 `[@repo]` セクションに、グローバルなデフォルト値とは異なる設定がされているのが分かると思います。
また、次のようなセクションがあると思います。

[source,ini]
----
[Talkhouse-master]
git-branch-name = master
view = //depot/Talkhouse/main-dev/... ...
----

//////////////////////////
This is a mapping between a Perforce branch and a Git branch.
The section can be named whatever you like, so long as the name is unique.
`git-branch-name` lets you convert a depot path that would be cumbersome under Git to a more friendly name.
The `view` setting controls how Perforce files are mapped into the Git repository, using the standard view mapping syntax.
More than one mapping can be specified, like in this example:
//////////////////////////
これは Perforce のブランチと Git のブランチのマッピングです。
このセクションの名前は好きなように決められるので、一意になるように長い名前も付けられます。
`git-branch-name` を使えば、Git にとってはとても長いディポのパスを、より扱いやすい名前に変換できます。
`view` では、 Perforce のファイルが Git のリポジトリへどう対応するかを、通常のビュー・マッピング用のシンタックスで設定します。
複数のマッピングを指定することもできます。次に例を示します。

[source,ini]
----
[multi-project-mapping]
git-branch-name = master
view = //depot/project1/main/... project1/...
       //depot/project2/mainline/... project2/...
----

//////////////////////////
This way, if your normal workspace mapping includes changes in the structure of the directories, you can replicate that with a Git repository.
//////////////////////////
通常のワークスペースのマッピングが、ディレクトリの構造の変更を含む場合、この方法では、それも含めてGitリポジトリを複製することができます。

//////////////////////////
The last file we'll discuss is `users/p4gf_usermap`, which maps Perforce users to Git users, and which you may not even need.
When converting from a Perforce changeset to a Git commit, Git Fusion's default behavior is to look up the Perforce user, and use the email address and full name stored there for the author/committer field in Git.
When converting the other way, the default is to look up the Perforce user with the email address stored in the Git commit's author field, and submit the changeset as that user (with permissions applying).
In most cases, this behavior will do just fine, but consider the following mapping file:
//////////////////////////
最後に取り上げるのは `users/p4gf_usermap` で、これは Perforce のユーザを Git のユーザにマッピングするファイルですが、必要ないかもしれません。
Perforce のチェンジセットを Git のコミットへ変換する際、 Git Fusion のデフォルトの動作では、 Perforce ユーザを探して、そのメールアドレスとフルネームを Git の作成者/コミッターフィールドに使用します。
逆の方向に変換する場合、デフォルトでは Git の作成者フィールドに格納されているメールアドレスで Perforce ユーザを検索し、そのユーザとしてチェンジセットを送信します（パーミッションも適用されます）。
ほとんどの場合、この動作で上手くいきます。ただし、次のマッピングファイルについても考慮しておいてください。

[source]
----
john john@example.com "John Doe"
john johnny@appleseed.net "John Doe"
bob employeeX@example.com "Anon X. Mouse"
joe employeeY@example.com "Anon Y. Mouse"
----

//////////////////////////
Each line is of the format `<user> <email> "<full name>"`, and creates a single user mapping.
The first two lines map two distinct email addresses to the same Perforce user account.
This is useful if you've created Git commits under several different email addresses (or change email addresses), but want them to be mapped to the same Perforce user.
When creating a Git commit from a Perforce changeset, the first line matching the Perforce user is used for Git authorship information.
//////////////////////////
各行のフォーマットは `<ユーザ名> <メールアドレス> "<氏名>"` となっています。一行ごとに一つ、ユーザの対応づけを定義しています。
最初の2行は、2つの異なるメールアドレスを同一の Perforce ユーザアカウントへ対応づけています。
これは、 Git のコミットを複数のメールアドレスで作成していた（または、メールアドレスを変更した）際に、それらを同じ Perforce へ対応づけたい場合に便利です。 
Perforce のチェンジセットから Git のコミットを作成する際には、 Perforce のユーザとマッチした最初の行が Git の作成者情報として使用されます。

//////////////////////////
The last two lines mask Bob and Joe's actual names and email addresses from the Git commits that are created.
This is nice if you want to open-source an internal project, but don't want to publish your employee directory to the entire world.
Note that the email addresses and full names should be unique, unless you want all the Git commits to be attributed to a single fictional author.
//////////////////////////
最後の2行は、Git のコミットから Bob と Joe の氏名とメールアドレスが分からないようにします。 
これは、社内のプロジェクトをオープンソース化したいが、社員名簿を全世界へ晒したくはない、というときに役立ちます。
注意すべき点として、すべての Git コミットが実際には存在しない1人のユーザによるものである、としたい場合を除き、メールアドレスと氏名は一意になるよう設定してください。

//////////////////////////
====== Workflow
//////////////////////////
====== ワークフロー

//////////////////////////
Perforce Git Fusion is a two-way bridge between Perforce and Git version control.
Let's have a look at how it feels to work from the Git side.
We'll assume we've mapped in the ``Jam'' project using a configuration file as shown above, which we can clone like this:
//////////////////////////
Perforce Git Fusion は Perforce と Git の間の双方向ブリッジです。
Gitの側から作業するとどんな感じなのかを見てみましょう。
ここでは、前述した設定ファイルを使用して ``Jam'' プロジェクトをマッピングしたと仮定しましょう。次のようにクローンが行えます。

[source,console]
----
$ git clone https://10.0.1.254/Jam
Cloning into 'Jam'...
Username for 'https://10.0.1.254': john
Password for 'https://ben@10.0.1.254':
remote: Counting objects: 2070, done.
remote: Compressing objects: 100% (1704/1704), done.
Receiving objects: 100% (2070/2070), 1.21 MiB | 0 bytes/s, done.
remote: Total 2070 (delta 1242), reused 0 (delta 0)
Resolving deltas: 100% (1242/1242), done.
Checking connectivity... done.
$ git branch -a
* master
  remotes/origin/HEAD -> origin/master
  remotes/origin/master
  remotes/origin/rel2.1
$ git log --oneline --decorate --graph --all
* 0a38c33 (origin/rel2.1) Create Jam 2.1 release branch.
| * d254865 (HEAD, origin/master, origin/HEAD, master) Upgrade to latest metrowerks on Beos -- the Intel one.
| * bd2f54a Put in fix for jam's NT handle leak.
| * c0f29e7 Fix URL in a jam doc
| * cc644ac Radstone's lynx port.
[...]
----

//////////////////////////
The first time you do this, it may take some time.
What's happening is that Git Fusion is converting all the applicable changesets in the Perforce history into Git commits.
This happens locally on the server, so it's relatively fast, but if you have a lot of history, it can still take some time.
Subsequent fetches do incremental conversion, so it'll feel more like Git's native speed.
//////////////////////////
最初にこれを実行した際には、ちょっと時間がかかるかもしれません。
ここで何が行われているかというと、 Git Fusion が、 Perforce の歴史中にある、適用可能なチェンジセットをすべて Git のコミットへ変換しています。
この処理はサーバ内部で行われるので、比較的高速ですが、大量の歴史がある場合には、ちょっと時間がかかります。
以降のフェッチでは増分だけを変換するので、体感的に Git 本来のスピードにより近づきます。

//////////////////////////
As you can see, our repository looks exactly like any other Git repository you might work with.
There are three branches, and Git has helpfully created a local `master` branch that tracks `origin/master`.
Let's do a bit of work, and create a couple of new commits:
//////////////////////////
見て分かるとおり、このリポジトリは普段作業している Git リポジトリと見た目上まったく変わりません。
3つのブランチがあり、 Git は親切なことに `origin/master` ブランチを追跡するローカルの `master` ブランチまで作成してくれています。
ちょっと作業をして、新しいコミットを2つほど作成してみましょう。

[source,console]
----
# ...
$ git log --oneline --decorate --graph --all
* cfd46ab (HEAD, master) Add documentation for new feature
* a730d77 Whitespace
* d254865 (origin/master, origin/HEAD) Upgrade to latest metrowerks on Beos -- the Intel one.
* bd2f54a Put in fix for jam's NT handle leak.
[...]
----

//////////////////////////
We have two new commits.
Now let's check if anyone else has been working:
//////////////////////////
新しいコミットが2つできました。
今度は、他の人が作業していなかったか確認してみましょう。

[source,console]
----
$ git fetch
remote: Counting objects: 5, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 2), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://10.0.1.254/Jam
   d254865..6afeb15  master     -> origin/master
$ git log --oneline --decorate --graph --all
* 6afeb15 (origin/master, origin/HEAD) Update copyright
| * cfd46ab (HEAD, master) Add documentation for new feature
| * a730d77 Whitespace
|/
* d254865 Upgrade to latest metrowerks on Beos -- the Intel one.
* bd2f54a Put in fix for jam's NT handle leak.
[...]
----

//////////////////////////
It looks like someone was!
You wouldn't know it from this view, but the `6afeb15` commit was actually created using a Perforce client.
It just looks like another commit from Git's point of view, which is exactly the point.
Let's see how the Perforce server deals with a merge commit:
//////////////////////////
誰かいたみたいですよ！
このビューからは分からなかったかも知れませんが、コミット `6afeb15` は Perforce クライアントを使用して実際に作成されたものです。
Git の視点から見ると、他のコミットと変わりませんが、 そこがポイントです。
Perforce サーバがマージコミットをどのように処理するのかを見てみましょう。

[source,console]
----
$ git merge origin/master
Auto-merging README
Merge made by the 'recursive' strategy.
 README | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
$ git push
Counting objects: 9, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (9/9), done.
Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, done.
Total 9 (delta 6), reused 0 (delta 0)
remote: Perforce: 100% (3/3) Loading commit tree into memory...
remote: Perforce: 100% (5/5) Finding child commits...
remote: Perforce: Running git fast-export...
remote: Perforce: 100% (3/3) Checking commits...
remote: Processing will continue even if connection is closed.
remote: Perforce: 100% (3/3) Copying changelists...
remote: Perforce: Submitting new Git commit objects to Perforce: 4
To https://10.0.1.254/Jam
   6afeb15..89cba2b  master -> master
----

//////////////////////////
Git thinks it worked.
Let's take a look at the history of the `README` file from Perforce's point of view, using the revision graph feature of `p4v`:
//////////////////////////
Git からは、うまくいったように見えているようです。
`p4v` のリビジョングラフ機能を使用して、 `README` ファイルの歴史を Perforce の視点から見てみましょう。

//////////////////////////
.Perforce revision graph resulting from Git push.
image::images/git-fusion-perforce-graph.png[Perforce revision graph resulting from Git push.]
//////////////////////////
.Git でのプッシュの結果作成される Perforce のリビジョングラフ
image::images/git-fusion-perforce-graph.png[Git でのプッシュの結果作成される Perforce のリビジョングラフ]

//////////////////////////
If you've never seen this view before, it may seem confusing, but it shows the same concepts as a graphical viewer for Git history.
We're looking at the history of the `README` file, so the directory tree at top left only shows that file as it surfaces in various branches.
At top right, we have a visual graph of how different revisions of the file are related, and the big-picture view of this graph is at bottom right.
The rest of the view is given to the details view for the selected revision (`2` in this case).
//////////////////////////
この画面を見たことがないと、混乱するかもしれませんが、 Git の歴史をグラフィカルに表示するビューアと同じ概念を示しています。
ここでは `README` ファイルの歴史を見ています。そのため、左上のディレクトリツリーでは、様々なブランチなかからそのファイルだけを取り上げて表示しています。
右上には、そのファイルの様々なリビジョンがどのように関連しているか、ビジュアライズされたグラフが表示されます。このグラフの全体像は右下にあります。
ビューの残りの部分では、選択したリビジョン（この場合は `2` ）の詳細を表示しています。

//////////////////////////
One thing to notice is that the graph looks exactly like the one in Git's history.
Perforce didn't have a named branch to store the `1` and `2` commits, so it made an ``anonymous'' branch in the `.git-fusion` directory to hold it.
This will also happen for named Git branches that don't correspond to a named Perforce branch (and you can later map them to a Perforce branch using the configuration file).
//////////////////////////
ひとつ注目してもらいたいのは、このグラフが Git の歴史のグラフとそっくりだということです。
Perforce にはコミット `1` および `2` を格納する名前つきのブランチがありません。代わりに ``anonymous'' ブランチを `.git-fusion` ディレクトリに作成し、そこに保管しています。
同様のことは、名前つきの Git のブランチに、対応する名前つきの Perforce のブランチがない場合にも起こります（設定ファイルを使えば、後でそのようなブランチを Perforce のブランチへ対応づけることも可能です）。

//////////////////////////
Most of this happens behind the scenes, but the end result is that one person on a team can be using Git, another can be using Perforce, and neither of them will know about the other's choice.
//////////////////////////
これのほとんどは舞台裏で行われますが、最終的には、ひとつのチームの中で、ある人は Git を使用し、またある人は Perforce を使用するということができ、その双方とも他の人が何を使用しているのかを知ることはない、という結果になりました。

//////////////////////////
====== Git-Fusion Summary
//////////////////////////
====== Git-Fusion のまとめ

//////////////////////////
If you have (or can get) access to your Perforce server, Git Fusion is a great way to make Git and Perforce talk to each other.
There's a bit of configuration involved, but the learning curve isn't very steep.
This is one of the few sections in this chapter where cautions about using Git's full power will not appear.
That's not to say that Perforce will be happy with everything you throw at it – if you try to rewrite history that's already been pushed, Git Fusion will reject it – but Git Fusion tries very hard to feel native.
You can even use Git submodules (though they'll look strange to Perforce users), and merge branches (this will be recorded as an integration on the Perforce side).
//////////////////////////
Perforce サーバへのアクセス権がある（または取得できる）なら、 Git Fusion は Git と Perforce が互いにやりとりできるようにする素晴らしい方法です。
多少の設定は必要ですが、学習曲線は急ではありません。
本節は、この章において、 Git の全機能を使用することに関して注意事項のない、数少ない節の一つです。
Perforce は指定した処理すべてを喜んでこなす、とは言いません – すでにプッシュ済みの歴史を書き換えようとしたら、 Git Fusion はそれをリジェクトします – ですが、 Git Fusion は Git そのままの感じになるよう非常に苦心しています。
また、Git のサブモジュールを使用したり（Perforce のユーザには変な風にみえますが）、ブランチのマージをしたり（Perforce 側では統合として記録されます）することも可能です。

//////////////////////////
If you can't convince the administrator of your server to set up Git Fusion, there is still a way to use these tools together.
//////////////////////////
Git Fusion をセットアップするようサーバの管理者を説得できなかったとしても、Git と Perforce を一緒に使用する方法は他にもあります。

===== Git-p4

(((git commands, p4)))
//////////////////////////
Git-p4 is a two-way bridge between Git and Perforce.
It runs entirely inside your Git repository, so you won't need any kind of access to the Perforce server (other than user credentials, of course).
Git-p4 isn't as flexible or complete a solution as Git Fusion, but it does allow you to do most of what you'd want to do without being invasive to the server environment.
//////////////////////////
git-p4 は、 Git と Perforce の間の双方向ブリッジです。
git-p4 は Git リポジトリの中だけで動作するので、 Perforce サーバにおけるいかなるアクセス権も必要としません（もちろん、ユーザ権限は必要ですが）。
git-p4 には Git Fusion ほどの柔軟性や完全性はありません。ですが、やりたいであろうことの大半を、サーバ環境に対して侵襲的になることなく実施できます。

[NOTE]
======
//////////////////////////
You'll need the `p4` tool somewhere in your `PATH` to work with git-p4.
As of this writing, it is freely available at http://www.perforce.com/downloads/Perforce/20-User[].
//////////////////////////
git-p4 で作業を行う場合、 `p4` ツールに `PATH` が通っている必要があります。
これを書いている時点では、 `p4` は http://www.perforce.com/downloads/Perforce/20-User[] から無料で入手できます。
======

//////////////////////////
====== Setting Up
//////////////////////////
====== セットアップ

//////////////////////////
For example purposes, we'll be running the Perforce server from the Git Fusion OVA as shown above, but we'll bypass the Git Fusion server and go directly to the Perforce version control.
//////////////////////////
例のため、前に見てきたとおり Perforce サーバを Git Fusion OVA で実行しますが、ここでは Git Fusion サーバをバイパスして、 Perforce のバージョン管理機能を直接使用します。

//////////////////////////
In order to use the `p4` command-line client (which git-p4 depends on), you'll need to set a couple of environment variables:
//////////////////////////
`p4` コマンドラインクライアント（ git-p4 がこれに依存している）を使用するには、環境変数を2つ設定する必要があります。

[source,console]
----
$ export P4PORT=10.0.1.254:1666
$ export P4USER=john
----

//////////////////////////
====== Getting Started
//////////////////////////
===== 使いはじめる

//////////////////////////
As with anything in Git, the first command is to clone:
//////////////////////////
Git でやるのと同様、最初にすることはクローンです。

[source,console]
----
$ git p4 clone //depot/www/live www-shallow
Importing from //depot/www/live into www-shallow
Initialized empty Git repository in /private/tmp/www-shallow/.git/
Doing initial import of //depot/www/live/ from revision #head into refs/remotes/p4/master
----

//////////////////////////
This creates what in Git terms is a ``shallow'' clone; only the very latest Perforce revision is imported into Git; remember, Perforce isn't designed to give every revision to every user.
This is enough to use Git as a Perforce client, but for other purposes it's not enough.
//////////////////////////
これで、 Git の用語で言う ``シャロー'' クローンが作成されます（Perforce の最新のリビジョンだけが Git へインポートされます）。覚えておいて欲しいのですが、 Perforce はすべてのリビジョンをすべてのユーザに渡すようデザインされてはいません。
Git を Perforce のクライアントとして使用するにはこれで十分ですが、それ以外の用途には不十分といえます。

//////////////////////////
Once it's finished, we have a fully-functional Git repository:
//////////////////////////
クローンが完了したら、十分な機能を備えた Git リポジトリの出来上がりです。

[source,console]
----
$ cd myproject
$ git log --oneline --all --graph --decorate
* 70eaf78 (HEAD, p4/master, p4/HEAD, master) Initial import of //depot/www/live/ from the state at revision #head
----

//////////////////////////
Note how there's a ``p4'' remote for the Perforce server, but everything else looks like a standard clone.
Actually, that's a bit misleading; there isn't actually a remote there.
//////////////////////////
Perforceを表す ``p4'' リモートがあることに注意が必要ですが、それ以外はすべて、通常のクローンと同じように見えます。
実際、これは少し誤解をまねきやすいのですが、実際にはリモートがあるわけではありません。

[source,console]
----
$ git remote -v
----

//////////////////////////
No remotes exist in this repository at all.
Git-p4 has created some refs to represent the state of the server, and they look like remote refs to `git log`, but they're not managed by Git itself, and you can't push to them.
//////////////////////////
このリポジトリにはリモートはひとつもありません。
git-p4 は、サーバの状態を表すために参照をいくつか作成します。これが `git log` からはリモート参照のように見えます。ですが、これらの参照は Git 自身が管理しているものではなく、またそこへプッシュすることもできません。

//////////////////////////
====== Workflow
//////////////////////////
===== ワークフロー

//////////////////////////
Okay, let's do some work.
Let's assume you've made some progress on a very important feature, and you're ready to show it to the rest of your team.
//////////////////////////
オーケー、それでは作業を始めましょう。
ここでは、ある非常に重要な機能に関して進捗があり、その成果をチームの他のメンバーに見せられる状態になっているとしましょう。

[source,console]
----
$ git log --oneline --all --graph --decorate
* 018467c (HEAD, master) Change page title
* c0fb617 Update link
* 70eaf78 (p4/master, p4/HEAD) Initial import of //depot/www/live/ from the state at revision #head
----

//////////////////////////
We've made two new commits that we're ready to submit to the Perforce server.
Let's check if anyone else was working today:
//////////////////////////
すでに2つのコミットを作成しており、Perforce サーバへ送信する準備もできています。
今日、他の誰かが作業をしていなかったか確認してみましょう。

[source,console]
----
$ git p4 sync
git p4 sync
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
Import destination: refs/remotes/p4/master
Importing revision 12142 (100%)
$ git log --oneline --all --graph --decorate
* 75cd059 (p4/master, p4/HEAD) Update copyright
| * 018467c (HEAD, master) Change page title
| * c0fb617 Update link
|/
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head
----

//////////////////////////
Looks like they were, and `master` and `p4/master` have diverged.
Perforce's branching system is _nothing_ like Git's, so submitting merge commits doesn't make any sense.
Git-p4 recommends that you rebase your commits, and even comes with a shortcut to do so:
//////////////////////////
誰かが作業をしていたようです。また、 `master` と `p4/master` が分岐しています。
Perforce のブランチのシステムは Git とは _まったく_ 異なり、マージコミットを送信しても意味をなしません。
git-p4 では、コミットをリベースすることを推奨しており、そのためのショートカットも用意されています。

[source,console]
----
$ git p4 rebase
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
No changes to import!
Rebasing the current branch onto remotes/p4/master
First, rewinding head to replay your work on top of it...
Applying: Update link
Applying: Change page title
 index.html | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
----

//////////////////////////
You can probably tell from the output, but `git p4 rebase` is a shortcut for `git p4 sync` followed by `git rebase p4/master`.
It's a bit smarter than that, especially when working with multiple branches, but this is a good approximation.
//////////////////////////
出力から分かったかと思いますが、 `git p4 rebase` は `git p4 sync` の後に `git rebase p4/master` を実行するショートカットです。
実際にはもう少し賢いのですが（特に複数のブランチで作業をしている場合には）、これはよい近似と言えます。

//////////////////////////
Now our history is linear again, and we're ready to contribute our changes back to Perforce.
The `git p4 submit` command will try to create a new Perforce revision for every Git commit between `p4/master` and `master`.
Running it drops us into our favorite editor, and the contents of the file look something like this:
//////////////////////////
これで歴史がリニアになり、変更を Perforce へ提供できる状態になりました。
`git p4 submit` を実行すると、 Git の `p4/master` から `master` の間の各コミットに対して Perforce のリビジョンを作成しようとします。
実行するとお好みのエディタが開かれます。ファイルの内容は次のような感じです。

[source,console]
----
# A Perforce Change Specification.
#
#  Change:      The change number. 'new' on a new changelist.
#  Date:        The date this specification was last modified.
#  Client:      The client on which the changelist was created.  Read-only.
#  User:        The user who created the changelist.
#  Status:      Either 'pending' or 'submitted'. Read-only.
#  Type:        Either 'public' or 'restricted'. Default is 'public'.
#  Description: Comments about the changelist.  Required.
#  Jobs:        What opened jobs are to be closed by this changelist.
#               You may delete jobs from this list.  (New changelists only.)
#  Files:       What opened files from the default changelist are to be added
#               to this changelist.  You may delete files from this list.
#               (New changelists only.)

Change:  new

Client:  john_bens-mbp_8487

User: john

Status:  new

Description:
   Update link

Files:
   //depot/www/live/index.html   # edit


######## git author ben@straub.cc does not match your p4 account.
######## Use option --preserve-user to modify authorship.
######## Variable git-p4.skipUserNameCheck hides this message.
######## everything below this line is just the diff #######
--- //depot/www/live/index.html  2014-08-31 18:26:05.000000000 0000
+++ /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/index.html   2014-08-31 18:26:05.000000000 0000
@@ -60,7 +60,7 @@
 </td>
 <td valign=top>
 Source and documentation for
-<a href="http://www.perforce.com/jam/jam.html">
+<a href="jam.html">
 Jam/MR</a>,
 a software build tool.
 </td>
----

//////////////////////////
This is mostly the same content you'd see by running `p4 submit`, except the stuff at the end which git-p4 has helpfully included.
Git-p4 tries to honor your Git and Perforce settings individually when it has to provide a name for a commit or changeset, but in some cases you want to override it.
For example, if the Git commit you're importing was written by a contributor who doesn't have a Perforce user account, you may still want the resulting changeset to look like they write it (and not you).
//////////////////////////
これは、 git-p4 が気を利かせて末尾に追加している内容を除けば、 `p4 submit` を実行した場合とほぼ同じ内容です。
git-p4 は、コミットやチェンジセットに対して氏名を指定する必要がある場合、 Git と Perforce で設定をそれぞれ個別に行えるようにしていますが、その設定を上書きしたい場合もあります。
例えば、 Git のコミットをインポートしていて、そのコミットの作成者が Perforce のユーザアカウントを持っていない場合を考えます。この場合、最終的にできるチェンジセットは（あなたではなく）そのコミットの作成者が書いたように見えるようにしたいだろうと思います。

//////////////////////////
Git-p4 has helpfully imported the message from the Git commit as the content for this Perforce changeset, so all we have to do is save and quit, twice (once for each commit).
The resulting shell output will look something like this:
//////////////////////////
git-p4 は気が利いていて、Git のコミットからメッセージをインポートして、この Perforce のチェンジセットの内容にセットしてくれます。そのため、ここではファイルの保存とエディタの終了を2回（コミット1つにつき1回）行うだけで済みます。
結果として、シェルへの出力は次のような感じになります。

[source,console]
----
$ git p4 submit
Perforce checkout for depot path //depot/www/live/ located at /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Synchronizing p4 checkout...
... - file(s) up-to-date.
Applying dbac45b Update link
//depot/www/live/index.html#4 - opened for edit
Change 12143 created with 1 open file(s).
Submitting change 12143.
Locking 1 files ...
edit //depot/www/live/index.html#5
Change 12143 submitted.
Applying 905ec6a Change page title
//depot/www/live/index.html#5 - opened for edit
Change 12144 created with 1 open file(s).
Submitting change 12144.
Locking 1 files ...
edit //depot/www/live/index.html#6
Change 12144 submitted.
All commits applied!
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
Import destination: refs/remotes/p4/master
Importing revision 12144 (100%)
Rebasing the current branch onto remotes/p4/master
First, rewinding head to replay your work on top of it...
$ git log --oneline --all --graph --decorate
* 775a46f (HEAD, p4/master, p4/HEAD, master) Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head
----

//////////////////////////
The result is as though we just did a `git push`, which is the closest analogy to what actually did happen.
//////////////////////////
出力は、実際に行われている処理にもっとも近いアナロジーとして、単に `git push` を実行したかのような内容になっています。 

//////////////////////////
Note that during this process every Git commit is turned into a Perforce changeset; if you want to squash them down into a single changeset, you can do that with an interactive rebase before running `git p4 submit`.
Also note that the SHA-1 hashes of all the commits that were submitted as changesets have changed; this is because git-p4 adds a line to the end of each commit it converts:
//////////////////////////
注意事項として、この処理では Git の各コミットが個別の Perforce のチェンジセットに変換されます。複数のコミットを1つのチェンジセットへスカッシュしたい場合は、 `git p4 submit` の前に対話的リベースを行ってください。
また、チェンジセットとして送信された全コミットの SHA-1 ハッシュが変更される点にも注意してください。これは、 git-p4 が変換した各コミットの末尾に行を追加するためです。

[source,console]
----
$ git log -1
commit 775a46f630d8b46535fc9983cf3ebe6b9aa53145
Author: John Doe <john@example.com>
Date:   Sun Aug 31 10:31:44 2014 -0800

    Change page title

    [git-p4: depot-paths = "//depot/www/live/": change = 12144]
----

//////////////////////////
What happens if you try to submit a merge commit?
Let's give it a try.
Here's the situation we've gotten ourselves into:
//////////////////////////
マージコミットを送信しようとした場合、何が起こるでしょうか？
やってみましょう。
現在の状況は次のようになっています。

[source,console]
----
$ git log --oneline --all --graph --decorate
* 3be6fd8 (HEAD, master) Correct email address
*   1dcbf21 Merge remote-tracking branch 'p4/master'
|\
| * c4689fc (p4/master, p4/HEAD) Grammar fix
* | cbacd0a Table borders: yes please
* | b4959b6 Trademark
|/
* 775a46f Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head
----

//////////////////////////
The Git and Perforce history diverge after 775a46f.
The Git side has two commits, then a merge commit with the Perforce head, then another commit.
We're going to try to submit these on top of a single changeset on the Perforce side.
Let's see what would happen if we tried to submit now:
//////////////////////////
Git と Perforce の歴史が 775a46f の後で分岐しています。
Git 側に2つのコミットがあり、次に Perforce 側の HEAD とのマージコミット、さらにその次にまた別のコミットがあります。
ここでは、これらすべてのコミットを Perforce 側のチェンジセットの一番上に追加してみます。
現時点で送信した場合に何が起こるか見てみましょう。

[source,console]
----
$ git p4 submit -n
Perforce checkout for depot path //depot/www/live/ located at /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Would synchronize p4 checkout in /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Would apply
  b4959b6 Trademark
  cbacd0a Table borders: yes please
  3be6fd8 Correct email address
----

//////////////////////////
The `-n` flag is short for `--dry-run`, which tries to report what would happen if the submit command were run for real.
In this case, it looks like we'd be creating three Perforce changesets, which correspond to the three non-merge commits that don't yet exist on the Perforce server.
That sounds like exactly what we want, let's see how it turns out:
//////////////////////////
`-n` フラグは `--dry-run` の省略形で、送信コマンドを本当に実行したら何が起こるかを表示してくれます。
この場合、 Perforce サーバに存在しない3つの非マージコミットに対応するように、 Perforce のチェンジセットを3つ作成するように見えます。
これは、望む結果そのもののように見えますので、結果どうなったか見てみましょう。

[source,console]
----
$ git p4 submit
[…]
$ git log --oneline --all --graph --decorate
* dadbd89 (HEAD, p4/master, p4/HEAD, master) Correct email address
* 1b79a80 Table borders: yes please
* 0097235 Trademark
* c4689fc Grammar fix
* 775a46f Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head
----

//////////////////////////
Our history became linear, just as though we had rebased before submitting (which is in fact exactly what happened).
This means you can be free to create, work on, throw away, and merge branches on the Git side without fear that your history will somehow become incompatible with Perforce.
If you can rebase it, you can contribute it to a Perforce server.
//////////////////////////
送信の前にリベースを実行したかのように（実際、それが行われているのですが）、歴史がリニアになりました。
これはつまり、Git 側ではブランチを作成したり、ブランチ上で作業したり、ブランチを放棄したり、ブランチをマージしたりといった作業を自由に行えること、その際に歴史が何らかの形で Perforce と非互換になってしまう心配もないということです。
リベースが行えるなら、その内容を Perforce サーバへ送信できます。

[[r_git_p4_branches]]
//////////////////////////
====== Branching
//////////////////////////
====== ブランチ

//////////////////////////
If your Perforce project has multiple branches, you're not out of luck; git-p4 can handle that in a way that makes it feel like Git.
Let's say your Perforce depot is laid out like this:
//////////////////////////
Perforce プロジェクトに複数のブランチがある場合でも、運の尽きというわけではありません。 git-p4 はそのようなプロジェクトを、 Git と同じように扱えます。
まず、 Perforce のディポが次のような内容になっているとしましょう。

[source]
----
//depot
  └── project
      ├── main
      └── dev
----

//////////////////////////
And let's say you have a `dev` branch, which has a view spec that looks like this:
//////////////////////////
さらに、次のようなビュー・スペックを持った `dev` ブランチがあるとしましょう。

[source]
----
//depot/project/main/... //depot/project/dev/...
----

//////////////////////////
Git-p4 can automatically detect that situation and do the right thing:
//////////////////////////
git-p4 はこのような状況を自動的に検出し、正しく処理を行います。

[source,console]
----
$ git p4 clone --detect-branches //depot/project@all
Importing from //depot/project@all into project
Initialized empty Git repository in /private/tmp/project/.git/
Importing revision 20 (50%)
    Importing new branch project/dev

    Resuming with change 20
Importing revision 22 (100%)
Updated branches: main dev
$ cd project; git log --oneline --all --graph --decorate
* eae77ae (HEAD, p4/master, p4/HEAD, master) main
| * 10d55fb (p4/project/dev) dev
| * a43cfae Populate //depot/project/main/... //depot/project/dev/....
|/
* 2b83451 Project init
----

//////////////////////////
Note the ``@all'' specifier in the depot path; that tells git-p4 to clone not just the latest changeset for that subtree, but all changesets that have ever touched those paths.
This is closer to Git's concept of a clone, but if you're working on a project with a long history, it could take a while.
//////////////////////////
ディポのパスに ``@all'' という指示子がついていることに注意してください。これは git-p4 に対して、パスの示すサブツリーの最新のチェンジセットだけでなく、そのパスにあったことのあるすべてのチェンジセットをクローンするように指示しています。
これは Git のクローンの考え方に近いですが、作業中のプロジェクトに長い歴史がある場合、ちょっと時間がかかるかもしれません。 

//////////////////////////
The `--detect-branches` flag tells git-p4 to use Perforce's branch specs to map the branches to Git refs.
If these mappings aren't present on the Perforce server (which is a perfectly valid way to use Perforce), you can tell git-p4 what the branch mappings are, and you get the same result:
//////////////////////////
`--detect-branches` フラグは、 git-p4 に対して、Perforce のブランチを Git の参照へマッピングする際に、 Perforce のブランチ仕様を使用するように指示しています。
そのようなマッピングが Perforce サーバになかった場合（これは Perforce を使う分にはまったく問題ないやり方ですが）でも、git-p4 に対してブランチのマッピングがどのようになっているかを指示でき、同じ結果が得られます。

[source,console]
----
$ git init project
Initialized empty Git repository in /tmp/project/.git/
$ cd project
$ git config git-p4.branchList main:dev
$ git clone --detect-branches //depot/project@all .
----

//////////////////////////
Setting the `git-p4.branchList` configuration variable to `main:dev` tells git-p4 that ``main'' and ``dev'' are both branches, and the second one is a child of the first one.
//////////////////////////
設定値 `git-p4.branchList` に `main:dev` を設定すると、 ``main'' と ``dev'' がいずれもブランチであること、2つめのブランチは1つめのブランチの子であることを git-p4 へ示します。

//////////////////////////
If we now `git checkout -b dev p4/project/dev` and make some commits, git-p4 is smart enough to target the right branch when we do `git p4 submit`.
Unfortunately, git-p4 can't mix shallow clones and multiple branches; if you have a huge project and want to work on more than one branch, you'll have to `git p4 clone` once for each branch you want to submit to.
//////////////////////////
ここで `git checkout -b dev p4/project/dev` を実行してからコミットを作成した場合でも、 git-p4 は充分に賢いので、 `git p4 submit` を実行した際には正しいブランチを対象にしてくれます。
なお、残念なことに、 git-p4 ではシャロークローンと複数ブランチを混ぜて使うことができません。巨大なプロジェクトにおいて複数のブランチで作業したい場合、ブランチごとに `git p4 clone` を実行する必要があります。

//////////////////////////
For creating or integrating branches, you'll have to use a Perforce client.
Git-p4 can only sync and submit to existing branches, and it can only do it one linear changeset at a time.
If you merge two branches in Git and try to submit the new changeset, all that will be recorded is a bunch of file changes; the metadata about which branches are involved in the integration will be lost.
//////////////////////////
また、ブランチの作成や統合には、 Perforce クライアントを使用する必要があります。
git-p4 にできるのは既存のブランチに対する同期と送信だけで、それも対象にできるのはリニアなチェンジセットを一度にひとつだけです。
Git で2つのブランチをマージして新しいチェンジセットを送信しても、一塊りのファイルの変更として記録されるだけです。マージの対象となったブランチはどれかといったメタデータは失われてしまいます。

//////////////////////////
===== Git and Perforce Summary
//////////////////////////
===== Git と Perforce のまとめ

//////////////////////////
Git-p4 makes it possible to use a Git workflow with a Perforce server, and it's pretty good at it.
However, it's important to remember that Perforce is in charge of the source, and you're only using Git to work locally.
Just be really careful about sharing Git commits; if you have a remote that other people use, don't push any commits that haven't already been submitted to the Perforce server.
//////////////////////////
git-p4 は、 Git のワークフローを Perforce サーバ上で使用できるようにします。また、それを非常にうまいやり方で可能にします。
ですが、大元を管理しているのはあくまで Perforce であり、 Git はローカルでの作業にのみ使用しているということは忘れないでください。
Git のコミットの共有については特に気をつけてください。他のメンバーが使用しているリモートがある場合、 Perforce サーバに送信していないコミットをプッシュしないよう気をつけてください。

//////////////////////////
If you want to freely mix the use of Perforce and Git as clients for source control, and you can convince the server administrator to install it, Git Fusion makes using Git a first-class version-control client for a Perforce server.
//////////////////////////
ソース管理のクライアントに Perforce と Git を自由に混ぜて使いたい場合、さらにサーバの管理者を説得してインストールの許可を貰える場合、Git Fusion は Git を Perforce サーバ用の第一級のバージョン管理クライアントにしてくれます。
